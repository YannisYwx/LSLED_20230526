package com.yannis.ledcard.util;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import java.nio.ByteBuffer;import java.nio.ByteOrder;import java.util.Formatter;import java.util.Locale;/** * Created by Cason on 2016/5/1. */public class DataUtils {    private static final char[] HEX_ARRAY = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};    private static final String HEX_STRING = "0123456789ABCDEF";    private static final String[] BINARY_ARRAY = {"0000", "0001", "0010", "0011", "0100", "0101", "0110", "0111", "1000", "1001", "1010", "1011", "1100", "1101", "1110", "1111"};    /**     * 高低位转换     *     * @param data     * @return     */    public static byte[] byteArrayReverse(byte[] data) {        for (int i = 0; i < data.length / 2; i++) {            byte temp = data[i];            data[i] = data[data.length - 1 - i];            data[data.length - 1 - i] = temp;        }        return data;    }    /**     * byte数组转成16进制字符串     *     * @param data 转换的数组     * @return 16进制的字符串表示形式(e.g: 6E0100048F)     */    public static String byteArray2String(byte[] data) {        StringBuffer buffer = new StringBuffer();        for (int i = 0; i < data.length; i++) {            String str = Integer.toHexString(data[i] & 0xFF);            if (str.length() < 2) {                buffer.append(0);            }            buffer.append(str.toUpperCase(Locale.getDefault()));        }        return buffer.toString();    }    /**     * byte数组转成16进制字符串(字节间用空格分开)     *     * @param data 转换的数组     * @return 16进制的字符串表示形式(e.g: 6E 01 00 04 8F)     */    public static String byteArray2StringWithSpaces(byte[] data) {        int len = data.length;        int[] x = new int[len];        String[] y = new String[len];        StringBuilder str = new StringBuilder();        // 转换成Int数组,然后转换成String数组        int j = 0;        for (; j < len; j++) {            x[j] = data[j] & 0xff;            y[j] = Integer.toHexString(x[j]);            while (y[j].length() < 2) {                y[j] = "0" + y[j];            }            str.append(y[j]);            str.append(" ");        }        return new String(str).toUpperCase();    }    /**     * 将byte数组转换为16进制字符串     *     * @param data 转换的数组     * @param len  数组长度     * @return 16进制的字符串表示形式(e.g: 0x6E0x010x000x040x8F)     */    public static String byteArray2HexString(byte[] data, int len) {        Formatter formatter = new Formatter();        byte[] buf = new byte[len];        System.arraycopy(data, 0, buf, 0, len);        int i;        for (i = 0; i < len; i++) {            formatter.format("0x%02X", buf[i]);        }        String result = formatter.toString();        formatter.close();        return result;    }    /**     * 将byte数组转换为16进制字符串     *     * @param data 转换的数组     * @param len  数组长度     * @return 16进制的字符串表示形式(e.g: 0x6E 0x01 0x00 0x04 0x8F)     */    public static String byteArray2HexStringWithSpaces(byte[] data, int len) {        Formatter formatter = new Formatter();        byte[] buf = new byte[len];        System.arraycopy(data, 0, buf, 0, len);        int i;        for (i = 0; i < len; i++) {            formatter.format("0x%02X ", buf[i]);        }        String result = formatter.toString();        formatter.close();        return result;    }    /**     * byte数组转换二进制字符串     *     * @param data     * @return 二进制的字符串表示形式(e.g: 1000111101100110000010001100110000011010)     */    public static String byteArray2BinaryString(byte[] data) {        String binaryStr = "";        int pos;        for (byte b : data) {            //高四位            pos = (b & 0xF0) >> 4;            binaryStr += BINARY_ARRAY[pos];            //低四位            pos = b & 0x0F;            binaryStr += BINARY_ARRAY[pos];        }        return binaryStr;    }    /**     * 把字符串去空格后转换成byte数组(e.g: "37 5a"-->{0x37, 0x5A})     *     * @param str 转换的字符串     * @return     */    public static byte[] string2ByteArray(String str) {        String s = str.replace(" ", "");        int string_len = s.length();        int len = string_len / 2;        if (string_len % 2 == 1) {            s = "0" + s;            string_len++;            len++;        }        byte[] data = new byte[len];        for (int i = 0; i < len; i++) {            data[i] = (byte) Integer.parseInt(s.substring(2 * i, 2 * i + 2), 16);        }        return data;    }    /**     * 二进制字符串转换byte数组(e.g: "0111111"-->{0x7F} or "0111111,0111111"-->{0x7F, 0x7F})     *     * @param binaryStr 二进制字符串(e.g: "0111111" or "0111111,0111111")     * @return     */    public static byte[] binaryString2ByteArrayByDot(String binaryStr) {        //假设binaryByte 是01，10，011，00以，分隔的格式的字符串        String[] binaryStrs = binaryStr.split(",");        byte[] data = new byte[binaryStrs.length];        for (int i = 0; i < data.length; i++) {            data[i] = (byte) parseInt(binaryStrs[i]);        }        int length = binaryStr.length();        if (length % 8 == 0) {            String[] bs = new String[length / 8];            for (int i = 0; i < length / 8; i++) {                bs[i] = binaryStr.substring(i * 8, i * 8 + 8);            }        }        return data;    }    /**     * 二进制字符串转换byte数组(e.g: "0111111"-->{0x7F} or "0111111,0111111"-->{0x7F, 0x7F})     *     * @param binaryStr 二进制字符串(e.g: "0111111" or "0111111,0111111")     * @return     */    public static byte[] binaryString2ByteArray(String binaryStr) {        int length = binaryStr.length();        if (length % 8 == 0) {            int byteLength = length / 8;            byte[] data = new byte[byteLength];            for (int i = 0; i < byteLength; i++) {                data[i] = (byte) parseInt(binaryStr.substring(i * 8, i * 8 + 8));            }            return data;        }        return null;    }    /**     * int转byte[]，低位在前，高位在后     *     * @param i 转换的int     * @return data     */    public static byte[] int2ByteArrayLSB(int i) {        byte b4 = (byte) ((i) >> 24);        byte b3 = (byte) (((i) << 8) >> 24);        byte b2 = (byte) (((i) << 16) >> 24);        byte b1 = (byte) (((i) << 24) >> 24);        byte[] bytes = {b1, b2, b3, b4};        return bytes;    }    /**     * int转byte[]，低位在前，高位在后     *     * @param i 转换的int     * @return data     */    public static byte[] int2ByteArrayLSB2(int i) {        byte[] data = new byte[2];        data[0] = (byte) (i & 0xFF);           // Least significant "byte"        data[1] = (byte) ((i & 0xFF00) >> 8);  // Most significant "byte"        return data;    }    /**     * int转byte数组     *     * @param i     * @param byteOrder 大小端排列顺序(e.g: ByteOrder.LITTLE_ENDIAN)     * @return     */    public static byte[] int2ByteArray(int i, ByteOrder byteOrder) {        ByteBuffer b = ByteBuffer.allocate(4);        b.order(byteOrder); // optional, the initial order of a byte buffer is always BIG_ENDIAN.        b.putInt(i);        return b.array();    }    /**     * 从数组里，指定位置转换出一个int(包括1~4字节)     *     * @param data        byte[]     * @param beginPos    int     * @param len         int     * @param isLowEndian boolean true 低位在前，高位在后, false 高位在前，低位在后     * @return int     */    public static int byteArray2Int(byte[] data, int beginPos, int len, boolean isLowEndian) {        if (beginPos > data.length - len) {            return 0;        }        int aInt = 0;        int tmpInt;        for (int i = 0; i < len; i++) {            tmpInt = data[i + beginPos];            if (tmpInt < 0) {                tmpInt += 256;            }            if (isLowEndian) {                tmpInt = tmpInt << (i * 8);            } else {                tmpInt = tmpInt << ((len - i - 1) * 8);            }            aInt |= tmpInt;        }        return aInt;    }    /**     * 2进制字符串转16进制字符串(e.g: "01111111"-->"7F")     *     * @param bStr 二进制字符串(e.g: "01111111")     * @return     */    public static String binaryString2hexString(String bStr) {        if (bStr == null || bStr.equals("") || bStr.length() % 8 != 0) {            return null;        }        StringBuffer tmp = new StringBuffer();        int iTmp = 0;        for (int i = 0; i < bStr.length(); i += 4) {            iTmp = 0;            for (int j = 0; j < 4; j++) {                iTmp += Integer.parseInt(bStr.substring(i + j, i + j + 1)) << (4 - j - 1);            }            tmp.append(Integer.toHexString(iTmp).toUpperCase());        }        return tmp.toString();    }    /**     * 16进制字符串转2进制字符串(e.g: "FF"-->"01111111")     *     * @param hexStr 16进制字符串(e.g: "FF")     * @return     */    public static String hexString2BinaryString(String hexStr) {        if (hexStr == null || hexStr.length() % 2 != 0) {            return null;        }        String bString = "", tmp;        for (int i = 0; i < hexStr.length(); i++) {            tmp = "0000"                    + Integer.toBinaryString(Integer.parseInt(hexStr                    .substring(i, i + 1), 16));            bString += tmp.substring(tmp.length() - 4);        }        return bString;    }    private static int parseInt(String str) {        //32位 为负数        if (32 == str.length()) {            str = "-" + str.substring(1);            return -(Integer.parseInt(str, 2) + Integer.MAX_VALUE + 1);        }        return Integer.parseInt(str, 2);    }    /**     * 将字节数组转换为Bitmap对象     *     * @param data 转换的数组     * @param opts     * @return Bitmap     */    public static Bitmap byteArray2Bitmap(byte[] data, BitmapFactory.Options opts) {        if (data != null) {            if (opts != null) {                return BitmapFactory.decodeByteArray(data, 0, data.length, opts);            } else {                return BitmapFactory.decodeByteArray(data, 0, data.length);            }        }        return null;    }    /**     * 获取一个整数的长度     *     * @param number     * @return     */    public static int getNubmerLength(long number) {        return (int) Math.log10(number) + 1;    }}